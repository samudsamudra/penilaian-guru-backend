DB_DSN=root:@tcp(127.0.0.1:3306)/penilaian_db?parseTime=true
GOOGLE_CLIENT_ID=1097816049037-bf819r7ls61o8jn2ptburh4d5dsobemc.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_REDIRECT_URL=http://localhost:8080/auth/google/callback
JWT_SECRET=jeki_penjual_balons
JWT_EXPIRE_HOURS=24
package config

import (
    "fmt"
    "log"
    "os"

    "github.com/joho/godotenv"
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

func LoadEnv() {
    err := godotenv.Load()
    if err != nil {
        log.Println("❗Warning: .env file not found. Using default env.")
    }
}

func ConnectDB() *gorm.DB {
    dsn := os.Getenv("DB_DSN") // contoh: "user:password@tcp(127.0.0.1:3306)/dbname?parseTime=true"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("❌ Gagal konek DB:", err)
    }
    fmt.Println("✅ Connected to DB!")
    DB = db
    return db
}
package controllers

import (
    "context"
    "net/http"
    "os"
    "penilaian_guru/services"

    "penilaian_guru/utils"

    "github.com/gin-gonic/gin"
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/google"
    oauth2api "google.golang.org/api/oauth2/v2"
    "google.golang.org/api/option"
    "gorm.io/gorm"
)

func getGoogleOAuthConfig() *oauth2.Config {
    return &oauth2.Config{
        RedirectURL:  os.Getenv("GOOGLE_REDIRECT_URL"),
        ClientID:     os.Getenv("GOOGLE_CLIENT_ID"),
        ClientSecret: os.Getenv("GOOGLE_CLIENT_SECRET"),
        Scopes: []string{
            "https://www.googleapis.com/auth/userinfo.email",
            "https://www.googleapis.com/auth/userinfo.profile",
        },
        Endpoint: google.Endpoint,
    }
}

func GoogleLogin(c *gin.Context) {
    conf := getGoogleOAuthConfig()
    url := conf.AuthCodeURL("randomstate")
    c.Redirect(http.StatusTemporaryRedirect, url)
}

func GoogleCallback(c *gin.Context, db *gorm.DB) {
    conf := getGoogleOAuthConfig()

    code := c.Query("code")
    if code == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Code not found"})
        return
    }

    token, err := conf.Exchange(context.Background(), code)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to exchange token"})
        return
    }
    oauth2Service, err := oauth2api.NewService(context.Background(), option.WithTokenSource(conf.TokenSource(context.Background(), token)))
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create oauth2 service"})
        return
    }

    userinfo, err := oauth2Service.Userinfo.Get().Do()
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user info"})
        return
    }

    // Buat atau ambil user dari database
    user, created, err := services.FindOrCreateUser(db, userinfo.Email, userinfo.Name)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal login / register user"})
        return
    }

    // Buat JWT token
    tokenString, err := utils.GenerateJWT(user.ID, user.Role)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal generate token"})
        return
    }

    msg := "Login berhasil"
    if created {
        msg = "Akun guru baru berhasil dibuat"
    }

    c.JSON(http.StatusOK, gin.H{
        "message": msg,
        "token":   tokenString,
        "user":    user,
    })
}
package controllers

import (
    "net/http"
    "penilaian_guru/services"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "gorm.io/gorm"
)

type SubmitVideoRequest struct {
    Link string `json:"link" binding:"required,url"`
}

func SubmitVideoHandler(c *gin.Context, db *gorm.DB) {
    guruID := c.MustGet("userID").(uuid.UUID)

    var req SubmitVideoRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Format link tidak valid."})
        return
    }

    submission, err := services.UpsertVideoSubmission(db, guruID, req.Link)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan video."})
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "message": "Video berhasil dikirim!",
        "data": gin.H{
            "link":       submission.Link,
            "updated_at": submission.UpdatedAt,
        },
    })
}
package controllerspackage main

import (
    "penilaian_guru/config"
    "penilaian_guru/models"
    "penilaian_guru/routes"

    "github.com/gin-gonic/gin"
)

func main() {
    // Load environment (.env)
    config.LoadEnv()

    // Konek ke database
    db := config.ConnectDB()

    // Auto-migrate semua model ke database
    db.AutoMigrate(&models.User{}, &models.VideoSubmission{}, &models.Penilaian{})

    // Setup router
    r := gin.Default()
    routes.SetupRoutes(r, db)

    // Jalankan server di port 8080
    r.Run(":8080")
    
}
package middlewares

import (
    "net/http"
    "penilaian_guru/utils"
    "strings"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "github.com/golang-jwt/jwt/v5"
)

func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }

        tokenStr := strings.TrimPrefix(authHeader, "Bearer ")
        token, err := utils.ParseJWT(tokenStr)
        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }

        claims := token.Claims.(jwt.MapClaims)
        userID, err := uuid.Parse(claims["user_id"].(string))
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID"})
            c.Abort()
            return
        }

        c.Set("userID", userID)
        c.Next()
    }
}
package middlewarespackage models

import (
    "github.com/google/uuid"
    "time"
)

type Penilaian struct {
    ID           uuid.UUID `gorm:"type:char(36);primaryKey"`
    VideoID      uuid.UUID `gorm:"type:char(36);not null;unique"`
    KepsekID     uuid.UUID `gorm:"type:char(36);not null"`
    SkorTotal    int       `gorm:"not null"`
    SkorPerAspek string    `gorm:"type:text"`
    Label        string    `gorm:"not null"`
    CreatedAt    time.Time

    Kepsek User `gorm:"foreignKey:KepsekID"`
}
package models

import "time"
import "github.com/google/uuid"

type User struct {
    ID        uuid.UUID `gorm:"type:char(36);primaryKey"`
    Name      string    `gorm:"not null"`
    Email     string    `gorm:"unique;not null"`
    Role      string    `gorm:"not null"`
    Sekolah   string    `gorm:"not null"`
    CreatedAt time.Time
    UpdatedAt time.Time
    Submissions []VideoSubmission `gorm:"foreignKey:GuruID"`
}
package models

import (
    "github.com/google/uuid"
    "time"
)

type VideoSubmission struct {
    ID        uuid.UUID `gorm:"type:char(36);primaryKey"`
    GuruID    uuid.UUID `gorm:"type:char(36);not null"`
    Link      string    `gorm:"not null"`
    CreatedAt time.Time
    UpdatedAt time.Time

    Guru      User
    Penilaian Penilaian `gorm:"foreignKey:VideoID"`
}
package routes

import (
    "penilaian_guru/controllers"

    "penilaian_guru/middlewares"

    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
)

func SetupRoutes(r *gin.Engine, db *gorm.DB) {
    r.GET("/ping", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "pong"})
    })

    guru := r.Group("/guru")
    guru.Use(middlewares.AuthMiddleware())
    {
        // Dummy: endpoint submit video
        guru.POST("/video", func(c *gin.Context) {
            controllers.SubmitVideoHandler(c, db)
        })
    }

    r.GET("/auth/google/login", controllers.GoogleLogin)
    r.GET("/auth/google/callback", func(c *gin.Context) {
        controllers.GoogleCallback(c, db)
    })
}
package services

import (
    "penilaian_guru/models"

    "github.com/google/uuid"
    "gorm.io/gorm"
)

func FindOrCreateUser(db *gorm.DB, email, name string) (*models.User, bool, error) {
    var user models.User
    err := db.Where("email = ?", email).First(&user).Error
    if err == nil {
        return &user, false, nil // udah ada
    }
    if err != gorm.ErrRecordNotFound {
        return nil, false, err // error lain
    }

    user = models.User{
        ID:      uuid.New(),
        Email:   email,
        Name:    name,
        Role:    "guru",
        Sekolah: "SMK Telkom Malang",
    }

    if err := db.Create(&user).Error; err != nil {
        return nil, false, err
    }
    return &user, true, nil
}
package services

import (
    "penilaian_guru/models"
    "time"

    "github.com/google/uuid"
    "gorm.io/gorm"
)

func UpsertVideoSubmission(db *gorm.DB, guruID uuid.UUID, link string) (*models.VideoSubmission, error) {
    var submission models.VideoSubmission
    err := db.Where("guru_id = ?", guruID).First(&submission).Error
    if err != nil && err != gorm.ErrRecordNotFound {
        return nil, err
    }

    if submission.ID != uuid.Nil {

        submission.Link = link
        submission.UpdatedAt = time.Now()
        if err := db.Save(&submission).Error; err != nil {
            return nil, err
        }
        return &submission, nil
    }
    submission = models.VideoSubmission{
        ID:     uuid.New(),
        GuruID: guruID,
        Link:   link,
    }
    if err := db.Create(&submission).Error; err != nil {
        return nil, err
    }
    return &submission, nil
}
package servicespackage utilspackage utils

import (
    "os"
    "strconv"
    "time"

    "github.com/golang-jwt/jwt/v5"
    "github.com/google/uuid"
)

func GenerateJWT(userID uuid.UUID, role string) (string, error) {
    expHours, _ := strconv.Atoi(os.Getenv("JWT_EXPIRE_HOURS"))
    claims := jwt.MapClaims{
        "user_id": userID.String(),
        "role":    role,
        "exp":     time.Now().Add(time.Duration(expHours) * time.Hour).Unix(),
        "iat":     time.Now().Unix(),
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(os.Getenv("JWT_SECRET")))
}

func ParseJWT(tokenStr string) (*jwt.Token, error) {
    return jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
        return []byte(os.Getenv("JWT_SECRET")), nil
    })
}
package utils